// This C code was automatically generated by Aixt Project
// Device = PIC24FJ128GA010
// Board = Explorer 16
// Backend = c


#include <xc.h>
#include <stdint.h>
#include <stdbool.h>
#define FCY 16000000UL
#pragma config POSCMOD = XT		//Primary Oscillator Select->XT Oscillator mode selected
#pragma config OSCIOFNC = ON    //Primary Oscillator Output Function->OSC2/CLKO/RC15 functions as port I/O (RC15)
#pragma config FCKSM = CSDCMD   //Clock Switching and Monitor->Clock switching and Fail-Safe Clock Monitor are disabled
#pragma config FNOSC = PRIPLL   //Oscillator Select->Primary Oscillator with PLL module (HSPLL, ECPLL)
#pragma config IESO = ON    	//Internal External Switch Over Mode->IESO mode (Two-Speed Start-up) enabled
#pragma config WDTPS = PS32768	//Watchdog Timer Postscaler->1:32768
#pragma config FWPSA = PR128    //WDT Prescaler->Prescaler ratio of 1:128
#pragma config WINDIS = ON    	//Watchdog Timer Window->Standard Watchdog Timer enabled,(Windowed-mode is disabled)
#pragma config FWDTEN = OFF    	//Watchdog Timer Enable->Watchdog Timer is disabled
#pragma config ICS = PGx2    	//Comm Channel Select->Emulator/debugger uses EMUC2/EMUD2
#pragma config BKBUG = OFF    	//Background Debug->Device resets into Operational mode
#pragma config GWRP = OFF    	//General Code Segment Write Protect->Writes to program memory are allowed
#pragma config GCP = OFF    	//General Code Segment Code Protect->Code protection is disabled
#pragma config JTAGEN = OFF    	//JTAG Port Enable->JTAG port is disabled
#define led3    A, 0			// Onboard LEDs
#define led4    A, 1
#define led5    A, 2
#define led6    A, 3
#define led7    A, 4
#define led8    A, 5
#define led9    A, 6
#define led10   A, 7
#define sw3     D, 6			// Onboard switchs
#define sw4     D, 13
#define sw5     A, 7
#define sw6     D, 7
#include <libpic30.h>
#define time__sleep_ms(TIME)    __delay_ms(TIME)
#define time__sleep_us(TIME)    __delay_us(TIME)
#define time__sleep(TIME)    __delay_ms(TIME*1000)
#define uart2__println(MSG)		uart2__print(MSG);  uart2__write('\n');  uart2__write('\r')
#define	uart2__write(DATA)  while(U2STAbits.UTXBF == 1){}  U2TXREG = DATA;
#define	uart2__any()	U2STAbits.URXDA

void main__init() ;
void uart2__setup(uint32_t baud_rate) ;
void uart2__print(char* msg);
uint8_t uart2__read(void);



void main__init() {
	AD1PCFG = 0xFFDF;     	// Analog inputs for Explorer16 POT and TSENS
	AD1CSSL = 0;           	// no scanning required
	AD1CON2 = 0;           	// use MUXA, AVss and AVdd are used as Vref+/-
	AD1CON3 = 0x1F02;      	// Tsamp = 32 x Tad; Tad=125ns
	AD1CON1bits.ADON = 1;  	// turn on the ADC

	TRISA = 0xff00;        	// select the PORTA pins as outputs to drive the LEDs
	TRISDbits.TRISD6 =  1;	// inputs switches
	TRISDbits.TRISD13 = 1;	 
	TRISDbits.TRISD7 =  1;	 
	TRISBbits.TRISB5 =  1;	// potentiometer
}


void uart2__setup(uint32_t baud_rate) {
    TRISFbits.TRISF4 = 1;   // Rx
    TRISFbits.TRISF5 = 0;   // Tx
    
    LATFbits.LATF5 = 1;     // Tx line initialization
    
    // STSEL 1; IREN disabled; PDSEL 8N; UARTEN enabled; RTSMD disabled; USIDL disabled; WAKE disabled; ABAUD disabled; LPBACK disabled; BRGH enabled; RXINV disabled; UEN TX_RX; 
    U2MODE = (0x8008 & ~(1<<15));  // disabling UARTEN bit   
    // UTXISEL0 TX_ONE_CHAR; UTXINV disabled; OERR NO_ERROR_cleared; URXISEL RX_ONE_CHAR; UTXBRK COMPLETED; UTXEN disabled; ADDEN disabled; 
    U2STA = 0x0000;
    //              FCY 
    // UBRG = ─────────────── - 1
    //         4 * baud_rate 
    U2BRG = (uint16_t)(FCY / (4 * baud_rate) - 1);
    
    U2MODEbits.UARTEN = 1;  // enabling UARTEN bit
    U2STAbits.UTXEN = 1;   
}


void uart2__print(char* msg){
    while(*msg != '\0'){
        uart2__write(*msg);
        msg++;
    }
}


uint8_t uart2__read(void){
    while(!(U2STAbits.URXDA == 1)){}

    if ((U2STAbits.OERR == 1)){
        U2STAbits.OERR = 0;
    }

    return U2RXREG;
}


int main(void ) {
main__init();
uart2__setup(115200);
while(true) {
uart2__write((uint8_t)(uart2__read()) + 1);
time__sleep_ms(200);
}
return 0;
}